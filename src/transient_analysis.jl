abstract type AbstractTransientAnalysisSpec <: AbstractAnalysisSpec end

"""
    TransientAnalysisSpec(; name, model, alg, start, stop, abstol, reltol, saveat, dtmax)

Transient analysis specification, specifying how a numerical `ODEProblem` would be formulated and solved.
The structure is an interface specification corresponding to
a [base analysis type in Dyad](https://symmetrical-adventure-kqpeovn.pages.github.io/design/analysis/).

When one creates an analysis in Dyad, the definition would look like

```
analysis RLCTransient
  extends Transient(abstol=10m, reltol=1m, start=0, stop=10.0, dtmax=0.1)
  parameter C::Capacitance=1m
  model = RLCModel(C=C)
end
```

where every analysis is defined by extending another analysis. To avoid infinite recursion, the `Transient` analysis
is defined by the DyadInterface package and is what we call a "base analysis", the above `RLCTransient`
being a "derived analysis".

The code for derived analyses is generated by the Dyad compiler and it will extend `run_analysis` to create
a concrete `TransientAnalysisSpec`.

# Keyword Arguments

  - `name`: The name of the analysis
  - `model`: An `ODESystem` representing the model that will be used for numerical integration
  - `alg`: The ODE integrator to use as a symbol. Possible options are: `:auto` (default), `:Rodas4`, `:FBDF`, `:Tsit5`
  - `start`: The start time for the integration. Defeults to 0.0
  - `stop`: The end time for the integration.
  - `abstol`: Absolute tolerance to use during the simulation. Defaults to 1e-6.
  - `reltol`: Relative tolerance to use during the simulation. Defaults to 1e-3.
  - `saveat`: Timepoints to save the solution at or `0` (for letting the integrator decide).
  - `dtmax`: The maximum allowed timestep or `0` (for letting the integrator decide).
"""
@kwdef struct TransientAnalysisSpec{S <: AbstractString, T1, T2, T3, M} <:
              AbstractTransientAnalysisSpec
    name::Symbol = :TransientAnalysis
    model::M
    alg::S = "auto"
    start::T1 = 0.0
    stop::T1
    abstol::T2 = 1e-6
    reltol::T3 = 1e-3
    saveat::Union{T1, Vector{<:T1}} = 0.0
    dtmax::T1 = 0.0
    IfLifting::Bool = false
end

function setup_prob(model, overrides, tspan, kwargs)
    ODEProblem{true, FullSpecialize}(model, overrides, tspan; kwargs...)
end

get_alg(spec::AbstractTransientAnalysisSpec) = spec.alg

function Base.show(io::IO, ::MIME"text/plain", spec::AbstractTransientAnalysisSpec)
    print(io, "Transient Analysis specification for ")
    printstyled(io, "$(nameof(spec))\n", color = :green, bold = true)
    # println(io, "overrides: [", join(spec.overrides, ", "), "]")
    println(io, "tspan: (", spec.start, ", ", spec.stop, ")")
    alg = get_alg(spec)
    print(io, "alg: ", alg)
end

struct TransientAnalysisSolution{SP <: TransientAnalysisSpec, S <: AbstractODESolution} <:
       AbstractAnalysisSolution
    spec::SP
    sol::S
    prob_expr::Expr
end

function Base.show(io::IO, m::MIME"text/plain", sol::TransientAnalysisSolution)
    printstyled(io, "Transient Analysis Solution for $(nameof(sol))\n",
        color = :blue, bold = true)
    show(io, m, sol.sol)
end

SciMLBase.successful_retcode(sol::TransientAnalysisSolution) = successful_retcode(sol.sol)

Base.nameof(sol::TransientAnalysisSolution) = sol.spec.name

function maybe_strip_sol(sol, arg)
    sol
end

# Use this to enable solution stripping
# function maybe_strip_sol(sol, ::Val{true})
#     strip_solution(sol)
# end

TransientAnalysis(; kwargs...) = run_analysis(TransientAnalysisSpec(; kwargs...))

function run_analysis(spec::TransientAnalysisSpec)
    # prepare
    config = ODEProblemConfig(spec)
    simplified_model = get_simplified_model(spec)
    prob = setup_prob(simplified_model, [], config.tspan, (;))

    # solve
    sol = solve(prob, config.alg; config.abstol, config.reltol, config.dtmax, config.saveat)

    # post-process
    # workaround for solution stripping issue
    stripped_sol = maybe_strip_sol(sol, Val(true))
    sys = sol.prob.f.sys
    prob_expr = ODEProblemExpr{true}(sys, [], config.tspan)

    stripped_spec = @set spec.model = nothing
    res = TransientAnalysisSolution(stripped_spec, stripped_sol, prob_expr)
    return res
end

function rebuild_sol(sol::TransientAnalysisSolution)
    prob = eval(sol.prob_expr)
    sol = sol.sol
    full_sol = @set sol.prob = prob

    return full_sol
end

function AnalysisSolutionMetadata(sol::TransientAnalysisSolution)
    name = :SimulationSolutionPlot
    type = ArtifactType.PlotlyPlot
    title = "Solution plot"
    description = "Transient solution plot for $(nameof(sol))."

    artifacts = [ArtifactMetadata(name, type, title, description)]

    push!(artifacts,
        ArtifactMetadata(
            :SimulationSolutionTable,
            ArtifactType.DataFrame,
            "Solution timeseries table",
            "Solution timeseries table for $(nameof(sol))"
        ))

    full_sol = rebuild_sol(sol)
    allowed_symbols = getname.(variable_symbols(full_sol))

    AnalysisSolutionMetadata(artifacts, allowed_symbols)
end

function artifacts(sol::TransientAnalysisSolution, name::Symbol)
    full_sol = rebuild_sol(sol)
    if name == :SimulationSolutionPlot
        plot(full_sol)
    elseif name == :SimulationSolutionTable
        DataFrame(full_sol)
    else
        error("Solution type $name not recognized!")
    end
end

function customizable_visualization(
        sol::TransientAnalysisSolution, vizdef::PlotlyVisualizationSpec)
    full_sol = rebuild_sol(sol)
    plot(full_sol; idxs = vizdef.symbols, vizdef.plots_attributes...)
end

# Plot recipe for convenient interactive usage
# This is implemented specifically for the TransientAnalysisSolution
# it's not something that is expected as part of the analysis interface
@recipe function f(sol::TransientAnalysisSolution)
    full_sol = rebuild_sol(sol)
    @series begin
        full_sol
    end
end

function SymbolicIndexingInterface.symbolic_container(sol::TransientAnalysisSolution)
    full_sol = rebuild_sol(sol)
    symbolic_container(full_sol.prob.f)
end
